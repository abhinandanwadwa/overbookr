// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: analytics.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getBookingsByStatusBetween = `-- name: GetBookingsByStatusBetween :many
SELECT status, COUNT(*)::bigint AS cnt
FROM bookings
WHERE created_at >= $1 AND created_at <= $2
GROUP BY status
`

type GetBookingsByStatusBetweenParams struct {
	CreatedAt   pgtype.Timestamptz
	CreatedAt_2 pgtype.Timestamptz
}

type GetBookingsByStatusBetweenRow struct {
	Status string
	Cnt    int64
}

func (q *Queries) GetBookingsByStatusBetween(ctx context.Context, arg GetBookingsByStatusBetweenParams) ([]GetBookingsByStatusBetweenRow, error) {
	rows, err := q.db.Query(ctx, getBookingsByStatusBetween, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBookingsByStatusBetweenRow
	for rows.Next() {
		var i GetBookingsByStatusBetweenRow
		if err := rows.Scan(&i.Status, &i.Cnt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookingsPerDayBetween = `-- name: GetBookingsPerDayBetween :many
SELECT
  (date_trunc('day', created_at))::timestamptz AS day,
  COUNT(*)::bigint AS bookings_count,
  COALESCE(SUM(seats), 0)::bigint AS seats_booked
FROM bookings
WHERE created_at >= $1 AND created_at <= $2
GROUP BY day
ORDER BY day
`

type GetBookingsPerDayBetweenParams struct {
	CreatedAt   pgtype.Timestamptz
	CreatedAt_2 pgtype.Timestamptz
}

type GetBookingsPerDayBetweenRow struct {
	Day           pgtype.Timestamptz
	BookingsCount int64
	SeatsBooked   int64
}

func (q *Queries) GetBookingsPerDayBetween(ctx context.Context, arg GetBookingsPerDayBetweenParams) ([]GetBookingsPerDayBetweenRow, error) {
	rows, err := q.db.Query(ctx, getBookingsPerDayBetween, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBookingsPerDayBetweenRow
	for rows.Next() {
		var i GetBookingsPerDayBetweenRow
		if err := rows.Scan(&i.Day, &i.BookingsCount, &i.SeatsBooked); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookingsTotalsBetween = `-- name: GetBookingsTotalsBetween :one
SELECT
  COUNT(*)::bigint AS total_bookings,
  COALESCE(SUM(seats), 0)::bigint AS total_seats_booked,
  COALESCE(SUM(CASE WHEN status = 'cancelled' THEN 1 ELSE 0 END), 0)::bigint AS total_cancellations,
  COALESCE(SUM(CASE WHEN status = 'active' THEN 1 ELSE 0 END), 0)::bigint AS total_active
FROM bookings
WHERE created_at >= $1 AND created_at <= $2
`

type GetBookingsTotalsBetweenParams struct {
	CreatedAt   pgtype.Timestamptz
	CreatedAt_2 pgtype.Timestamptz
}

type GetBookingsTotalsBetweenRow struct {
	TotalBookings      int64
	TotalSeatsBooked   int64
	TotalCancellations int64
	TotalActive        int64
}

func (q *Queries) GetBookingsTotalsBetween(ctx context.Context, arg GetBookingsTotalsBetweenParams) (GetBookingsTotalsBetweenRow, error) {
	row := q.db.QueryRow(ctx, getBookingsTotalsBetween, arg.CreatedAt, arg.CreatedAt_2)
	var i GetBookingsTotalsBetweenRow
	err := row.Scan(
		&i.TotalBookings,
		&i.TotalSeatsBooked,
		&i.TotalCancellations,
		&i.TotalActive,
	)
	return i, err
}

const getEventUtilizationBetween = `-- name: GetEventUtilizationBetween :many
SELECT
  e.id AS event_id,
  e.name,
  e.capacity::int AS capacity,
  e.booked_count::int AS booked_count,
  COALESCE(b.cnt, 0)::bigint AS bookings_seats_in_range
FROM events e
LEFT JOIN (
  SELECT event_id, COALESCE(SUM(seats), 0)::bigint AS cnt
  FROM bookings b
  WHERE b.created_at >= $1 AND b.created_at <= $2
  GROUP BY event_id
) b ON b.event_id = e.id
ORDER BY e.booked_count DESC
LIMIT $3
`

type GetEventUtilizationBetweenParams struct {
	CreatedAt   pgtype.Timestamptz
	CreatedAt_2 pgtype.Timestamptz
	Limit       int32
}

type GetEventUtilizationBetweenRow struct {
	EventID              pgtype.UUID
	Name                 string
	Capacity             int32
	BookedCount          int32
	BookingsSeatsInRange int64
}

func (q *Queries) GetEventUtilizationBetween(ctx context.Context, arg GetEventUtilizationBetweenParams) ([]GetEventUtilizationBetweenRow, error) {
	rows, err := q.db.Query(ctx, getEventUtilizationBetween, arg.CreatedAt, arg.CreatedAt_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventUtilizationBetweenRow
	for rows.Next() {
		var i GetEventUtilizationBetweenRow
		if err := rows.Scan(
			&i.EventID,
			&i.Name,
			&i.Capacity,
			&i.BookedCount,
			&i.BookingsSeatsInRange,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopEventsBySeatsBetween = `-- name: GetTopEventsBySeatsBetween :many
SELECT
  b.event_id,
  e.name,
  COUNT(*)::bigint AS bookings_count,
  COALESCE(SUM(b.seats), 0)::bigint AS seats_booked,
  e.capacity::int AS capacity,
  e.booked_count::int AS booked_count
FROM bookings b
JOIN events e ON e.id = b.event_id
WHERE b.created_at >= $1 AND b.created_at <= $2
GROUP BY b.event_id, e.name, e.capacity, e.booked_count
ORDER BY seats_booked DESC
LIMIT $3
`

type GetTopEventsBySeatsBetweenParams struct {
	CreatedAt   pgtype.Timestamptz
	CreatedAt_2 pgtype.Timestamptz
	Limit       int32
}

type GetTopEventsBySeatsBetweenRow struct {
	EventID       pgtype.UUID
	Name          string
	BookingsCount int64
	SeatsBooked   int64
	Capacity      int32
	BookedCount   int32
}

func (q *Queries) GetTopEventsBySeatsBetween(ctx context.Context, arg GetTopEventsBySeatsBetweenParams) ([]GetTopEventsBySeatsBetweenRow, error) {
	rows, err := q.db.Query(ctx, getTopEventsBySeatsBetween, arg.CreatedAt, arg.CreatedAt_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopEventsBySeatsBetweenRow
	for rows.Next() {
		var i GetTopEventsBySeatsBetweenRow
		if err := rows.Scan(
			&i.EventID,
			&i.Name,
			&i.BookingsCount,
			&i.SeatsBooked,
			&i.Capacity,
			&i.BookedCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
