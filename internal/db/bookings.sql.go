// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: bookings.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const convertSeatHoldToConverted = `-- name: ConvertSeatHoldToConverted :exec
UPDATE seat_holds
SET status = 'converted'
WHERE hold_token = $1
`

func (q *Queries) ConvertSeatHoldToConverted(ctx context.Context, holdToken string) error {
	_, err := q.db.Exec(ctx, convertSeatHoldToConverted, holdToken)
	return err
}

const getBookingByEventAndIdempotency = `-- name: GetBookingByEventAndIdempotency :one
SELECT id, event_id, user_id, seats, seat_ids, status, idempotency_key, created_at, updated_at
FROM bookings
WHERE event_id = $1
    AND idempotency_key = $2
`

type GetBookingByEventAndIdempotencyParams struct {
	EventID        pgtype.UUID
	IdempotencyKey pgtype.Text
}

func (q *Queries) GetBookingByEventAndIdempotency(ctx context.Context, arg GetBookingByEventAndIdempotencyParams) (Booking, error) {
	row := q.db.QueryRow(ctx, getBookingByEventAndIdempotency, arg.EventID, arg.IdempotencyKey)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.UserID,
		&i.Seats,
		&i.SeatIds,
		&i.Status,
		&i.IdempotencyKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBookingByID = `-- name: GetBookingByID :one
SELECT id, event_id, user_id, seats, seat_ids, status, idempotency_key, created_at, updated_at
FROM bookings
WHERE id = $1
`

func (q *Queries) GetBookingByID(ctx context.Context, id pgtype.UUID) (Booking, error) {
	row := q.db.QueryRow(ctx, getBookingByID, id)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.UserID,
		&i.Seats,
		&i.SeatIds,
		&i.Status,
		&i.IdempotencyKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBookingsByUser = `-- name: GetBookingsByUser :many
SELECT id, event_id, user_id, seats, seat_ids, status, idempotency_key, created_at, updated_at
FROM bookings
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetBookingsByUser(ctx context.Context, userID pgtype.UUID) ([]Booking, error) {
	rows, err := q.db.Query(ctx, getBookingsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.UserID,
			&i.Seats,
			&i.SeatIds,
			&i.Status,
			&i.IdempotencyKey,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeatHoldForUpdateByToken = `-- name: GetSeatHoldForUpdateByToken :one
SELECT id, hold_token, event_id, user_id, expires_at, status
FROM seat_holds
WHERE hold_token = $1
FOR UPDATE
`

type GetSeatHoldForUpdateByTokenRow struct {
	ID        pgtype.UUID
	HoldToken string
	EventID   pgtype.UUID
	UserID    pgtype.UUID
	ExpiresAt pgtype.Timestamptz
	Status    string
}

func (q *Queries) GetSeatHoldForUpdateByToken(ctx context.Context, holdToken string) (GetSeatHoldForUpdateByTokenRow, error) {
	row := q.db.QueryRow(ctx, getSeatHoldForUpdateByToken, holdToken)
	var i GetSeatHoldForUpdateByTokenRow
	err := row.Scan(
		&i.ID,
		&i.HoldToken,
		&i.EventID,
		&i.UserID,
		&i.ExpiresAt,
		&i.Status,
	)
	return i, err
}

const getSeatNosByIds = `-- name: GetSeatNosByIds :many
SELECT seat_no
FROM seats
WHERE id = ANY($1::uuid[])
ORDER BY seat_no
`

func (q *Queries) GetSeatNosByIds(ctx context.Context, dollar_1 []pgtype.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getSeatNosByIds, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var seat_no string
		if err := rows.Scan(&seat_no); err != nil {
			return nil, err
		}
		items = append(items, seat_no)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeatsForBookingByIDs = `-- name: GetSeatsForBookingByIDs :many
SELECT id, status, hold_token
FROM seats
WHERE id = ANY($1::uuid[])
ORDER BY id
FOR UPDATE
`

type GetSeatsForBookingByIDsRow struct {
	ID        pgtype.UUID
	Status    string
	HoldToken pgtype.Text
}

func (q *Queries) GetSeatsForBookingByIDs(ctx context.Context, dollar_1 []pgtype.UUID) ([]GetSeatsForBookingByIDsRow, error) {
	rows, err := q.db.Query(ctx, getSeatsForBookingByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSeatsForBookingByIDsRow
	for rows.Next() {
		var i GetSeatsForBookingByIDsRow
		if err := rows.Scan(&i.ID, &i.Status, &i.HoldToken); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertBooking = `-- name: InsertBooking :one
INSERT INTO bookings (event_id, user_id, seats, seat_ids, status, idempotency_key)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, event_id, user_id, seats, seat_ids, status, idempotency_key, created_at
`

type InsertBookingParams struct {
	EventID        pgtype.UUID
	UserID         pgtype.UUID
	Seats          int32
	SeatIds        []pgtype.UUID
	Status         string
	IdempotencyKey pgtype.Text
}

type InsertBookingRow struct {
	ID             pgtype.UUID
	EventID        pgtype.UUID
	UserID         pgtype.UUID
	Seats          int32
	SeatIds        []pgtype.UUID
	Status         string
	IdempotencyKey pgtype.Text
	CreatedAt      pgtype.Timestamptz
}

func (q *Queries) InsertBooking(ctx context.Context, arg InsertBookingParams) (InsertBookingRow, error) {
	row := q.db.QueryRow(ctx, insertBooking,
		arg.EventID,
		arg.UserID,
		arg.Seats,
		arg.SeatIds,
		arg.Status,
		arg.IdempotencyKey,
	)
	var i InsertBookingRow
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.UserID,
		&i.Seats,
		&i.SeatIds,
		&i.Status,
		&i.IdempotencyKey,
		&i.CreatedAt,
	)
	return i, err
}

const updateEventBookedCount = `-- name: UpdateEventBookedCount :execrows
UPDATE events
SET booked_count = booked_count + $1
WHERE id = $2
  AND booked_count + $1 <= capacity
`

type UpdateEventBookedCountParams struct {
	BookedCount int32
	ID          pgtype.UUID
}

func (q *Queries) UpdateEventBookedCount(ctx context.Context, arg UpdateEventBookedCountParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateEventBookedCount, arg.BookedCount, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateSeatsToBooked = `-- name: UpdateSeatsToBooked :exec
UPDATE seats
SET STATUS = 'booked',
    booking_id = $1,
    hold_expires_at = NULL,
    hold_token = NULL
WHERE id = ANY($2::uuid[])
`

type UpdateSeatsToBookedParams struct {
	BookingID pgtype.UUID
	Column2   []pgtype.UUID
}

func (q *Queries) UpdateSeatsToBooked(ctx context.Context, arg UpdateSeatsToBookedParams) error {
	_, err := q.db.Exec(ctx, updateSeatsToBooked, arg.BookingID, arg.Column2)
	return err
}
