// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: waitlist.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAvailableSeatsForEventForUpdate = `-- name: GetAvailableSeatsForEventForUpdate :many
SELECT id, seat_no
FROM seats
WHERE event_id = $1
    AND status = 'available'
ORDER BY id
LIMIT $2
FOR UPDATE
`

type GetAvailableSeatsForEventForUpdateParams struct {
	EventID pgtype.UUID
	Limit   int32
}

type GetAvailableSeatsForEventForUpdateRow struct {
	ID     pgtype.UUID
	SeatNo string
}

func (q *Queries) GetAvailableSeatsForEventForUpdate(ctx context.Context, arg GetAvailableSeatsForEventForUpdateParams) ([]GetAvailableSeatsForEventForUpdateRow, error) {
	rows, err := q.db.Query(ctx, getAvailableSeatsForEventForUpdate, arg.EventID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAvailableSeatsForEventForUpdateRow
	for rows.Next() {
		var i GetAvailableSeatsForEventForUpdateRow
		if err := rows.Scan(&i.ID, &i.SeatNo); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWaitingListByEvent = `-- name: GetWaitingListByEvent :many
SELECT id, event_id, user_id, requested_seats, position, status, created_at
FROM waitlist
WHERE event_id = $1 AND status = 'waiting'
ORDER BY position, created_at
`

type GetWaitingListByEventRow struct {
	ID             pgtype.UUID
	EventID        pgtype.UUID
	UserID         pgtype.UUID
	RequestedSeats int32
	Position       int64
	Status         string
	CreatedAt      pgtype.Timestamptz
}

func (q *Queries) GetWaitingListByEvent(ctx context.Context, eventID pgtype.UUID) ([]GetWaitingListByEventRow, error) {
	rows, err := q.db.Query(ctx, getWaitingListByEvent, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWaitingListByEventRow
	for rows.Next() {
		var i GetWaitingListByEventRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.UserID,
			&i.RequestedSeats,
			&i.Position,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertWaitlist = `-- name: InsertWaitlist :one
INSERT INTO waitlist (event_id, user_id, requested_seats, position, status)
VALUES (
    $1,
    $2,
    $3,
    (SELECT COALESCE(MAX(position), 0) + 1 FROM waitlist WHERE event_id = $1),
    'waiting'
)
RETURNING id, position, created_at
`

type InsertWaitlistParams struct {
	EventID        pgtype.UUID
	UserID         pgtype.UUID
	RequestedSeats int32
}

type InsertWaitlistRow struct {
	ID        pgtype.UUID
	Position  int64
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) InsertWaitlist(ctx context.Context, arg InsertWaitlistParams) (InsertWaitlistRow, error) {
	row := q.db.QueryRow(ctx, insertWaitlist, arg.EventID, arg.UserID, arg.RequestedSeats)
	var i InsertWaitlistRow
	err := row.Scan(&i.ID, &i.Position, &i.CreatedAt)
	return i, err
}

const updateWaitlistStatus = `-- name: UpdateWaitlistStatus :exec
UPDATE waitlist
SET status = $2
WHERE id = $1
`

type UpdateWaitlistStatusParams struct {
	ID     pgtype.UUID
	Status string
}

func (q *Queries) UpdateWaitlistStatus(ctx context.Context, arg UpdateWaitlistStatusParams) error {
	_, err := q.db.Exec(ctx, updateWaitlistStatus, arg.ID, arg.Status)
	return err
}
